/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * API ÏÑúÎ≤Ñ
 * ÌåÄ12 2Ï∞® ÌîÑÎ°úÏ†ùÌä∏ API ÏÑúÎ≤Ñ Î¨∏ÏÑúÏûÖÎãàÎã§.
 * OpenAPI spec version: beta
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CommentRequestDto,
  CommentUpdateRequestDto,
  DiaryUpdateRequestDto,
  DiaryWriteRequestDto,
  EmotionGraphResponse,
  FollowUserParams,
  FollowUserResponse,
  GenreGraphResponse,
  GetEmotionGraphParams,
  GetFollowersParams,
  GetFollowingsParams,
  GetGenreGraphParams,
  GetLikeCountParams,
  GetOttGraphParams,
  GetPendingRequestsParams,
  GetSentRequestsParams,
  GetTypeGraphParams,
  LikeCountResponse,
  LikeResponse,
  LoginRequest,
  MonthlyDiaryCount,
  OttGraphResponse,
  ReportRequest,
  RsDataCommentResponseDto,
  RsDataContentResponseDto,
  RsDataDiaryDetailDto,
  RsDataDiaryResponseDto,
  RsDataListCommentResponseDto,
  RsDataListContentSearchResultDto,
  RsDataListTagResponse,
  RsDataLoginResponse,
  RsDataMyProfileResponse,
  RsDataObject,
  RsDataPageResponseUserProfileResponse,
  RsDataUserProfileResponse,
  RsDataVoid,
  SearchContentsParams,
  SearchUsersParams,
  SignupRequest,
  StatisticsCardDto,
  TimelineResponse,
  TypeCountDto,
  TypeGraphResponse,
  UnfollowUserParams
} from '../model';

import { customInstance } from '../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */
export const getDiary = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataDiaryDetailDto>(
      {url: `/api/v1/diaries/${diaryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDiaryQueryKey = (diaryId?: number,) => {
    return [`/api/v1/diaries/${diaryId}`] as const;
    }

    
export const getGetDiaryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiaryQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiary>>> = ({ signal }) => getDiary(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDiaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDiary>>>
export type GetDiaryInfiniteQueryError = unknown


export function useGetDiaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDiaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDiaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */

export function useGetDiaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDiaryInfiniteQueryOptions(diaryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDiaryQueryOptions = <TData = Awaited<ReturnType<typeof getDiary>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiaryQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiary>>> = ({ signal }) => getDiary(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDiaryQueryResult = NonNullable<Awaited<ReturnType<typeof getDiary>>>
export type GetDiaryQueryError = unknown


export function useGetDiary<TData = Awaited<ReturnType<typeof getDiary>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDiary<TData = Awaited<ReturnType<typeof getDiary>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDiary<TData = Awaited<ReturnType<typeof getDiary>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */

export function useGetDiary<TData = Awaited<ReturnType<typeof getDiary>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDiaryQueryOptions(diaryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏàòÏ†ï
 */
export const updateDiary = (
    diaryId: number,
    diaryUpdateRequestDto: DiaryUpdateRequestDto,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RsDataDiaryResponseDto>(
      {url: `/api/v1/diaries/${diaryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: diaryUpdateRequestDto
    },
      options);
    }
  


export const getUpdateDiaryMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDiary>>, TError,{diaryId: number;data: DiaryUpdateRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDiary>>, TError,{diaryId: number;data: DiaryUpdateRequestDto}, TContext> => {

const mutationKey = ['updateDiary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDiary>>, {diaryId: number;data: DiaryUpdateRequestDto}> = (props) => {
          const {diaryId,data} = props ?? {};

          return  updateDiary(diaryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDiaryMutationResult = NonNullable<Awaited<ReturnType<typeof updateDiary>>>
    export type UpdateDiaryMutationBody = DiaryUpdateRequestDto
    export type UpdateDiaryMutationError = unknown

    /**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏàòÏ†ï
 */
export const useUpdateDiary = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDiary>>, TError,{diaryId: number;data: DiaryUpdateRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDiary>>,
        TError,
        {diaryId: number;data: DiaryUpdateRequestDto},
        TContext
      > => {

      const mutationOptions = getUpdateDiaryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏÇ≠Ï†ú
 */
export const deleteDiary = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RsDataVoid>(
      {url: `/api/v1/diaries/${diaryId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDiaryMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDiary>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDiary>>, TError,{diaryId: number}, TContext> => {

const mutationKey = ['deleteDiary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDiary>>, {diaryId: number}> = (props) => {
          const {diaryId} = props ?? {};

          return  deleteDiary(diaryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDiaryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDiary>>>
    
    export type DeleteDiaryMutationError = unknown

    /**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏÇ≠Ï†ú
 */
export const useDeleteDiary = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDiary>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDiary>>,
        TError,
        {diaryId: number},
        TContext
      > => {

      const mutationOptions = getDeleteDiaryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const updateComment = (
    commentUpdateRequestDto: CommentUpdateRequestDto,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RsDataVoid>(
      {url: `/api/v1/comments`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: commentUpdateRequestDto
    },
      options);
    }
  


export const getUpdateCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateComment>>, TError,{data: CommentUpdateRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateComment>>, TError,{data: CommentUpdateRequestDto}, TContext> => {

const mutationKey = ['updateComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateComment>>, {data: CommentUpdateRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  updateComment(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateComment>>>
    export type UpdateCommentMutationBody = CommentUpdateRequestDto
    export type UpdateCommentMutationError = unknown

    /**
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const useUpdateComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateComment>>, TError,{data: CommentUpdateRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateComment>>,
        TError,
        {data: CommentUpdateRequestDto},
        TContext
      > => {

      const mutationOptions = getUpdateCommentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÎåìÍ∏Ä Îì±Î°ù
 */
export const writeComment = (
    commentRequestDto: CommentRequestDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataCommentResponseDto>(
      {url: `/api/v1/comments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: commentRequestDto, signal
    },
      options);
    }
  


export const getWriteCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof writeComment>>, TError,{data: CommentRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof writeComment>>, TError,{data: CommentRequestDto}, TContext> => {

const mutationKey = ['writeComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof writeComment>>, {data: CommentRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  writeComment(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WriteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof writeComment>>>
    export type WriteCommentMutationBody = CommentRequestDto
    export type WriteCommentMutationError = unknown

    /**
 * @summary ÎåìÍ∏Ä Îì±Î°ù
 */
export const useWriteComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof writeComment>>, TError,{data: CommentRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof writeComment>>,
        TError,
        {data: CommentRequestDto},
        TContext
      > => {

      const mutationOptions = getWriteCommentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const reportUser = (
    reportRequest: ReportRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataObject>(
      {url: `/api/v1/reports`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reportRequest, signal
    },
      options);
    }
  


export const getReportUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportUser>>, TError,{data: ReportRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof reportUser>>, TError,{data: ReportRequest}, TContext> => {

const mutationKey = ['reportUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportUser>>, {data: ReportRequest}> = (props) => {
          const {data} = props ?? {};

          return  reportUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReportUserMutationResult = NonNullable<Awaited<ReturnType<typeof reportUser>>>
    export type ReportUserMutationBody = ReportRequest
    export type ReportUserMutationError = unknown

    export const useReportUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportUser>>, TError,{data: ReportRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reportUser>>,
        TError,
        {data: ReportRequest},
        TContext
      > => {

      const mutationOptions = getReportUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const like = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LikeResponse>(
      {url: `/api/v1/likes/${diaryId}`, method: 'POST', signal
    },
      options);
    }
  


export const getLikeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof like>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof like>>, TError,{diaryId: number}, TContext> => {

const mutationKey = ['like'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof like>>, {diaryId: number}> = (props) => {
          const {diaryId} = props ?? {};

          return  like(diaryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LikeMutationResult = NonNullable<Awaited<ReturnType<typeof like>>>
    
    export type LikeMutationError = unknown

    /**
 * @summary Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const useLike = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof like>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof like>>,
        TError,
        {diaryId: number},
        TContext
      > => {

      const mutationOptions = getLikeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const unlike = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LikeResponse>(
      {url: `/api/v1/likes/${diaryId}`, method: 'DELETE'
    },
      options);
    }
  


export const getUnlikeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlike>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unlike>>, TError,{diaryId: number}, TContext> => {

const mutationKey = ['unlike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlike>>, {diaryId: number}> = (props) => {
          const {diaryId} = props ?? {};

          return  unlike(diaryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlikeMutationResult = NonNullable<Awaited<ReturnType<typeof unlike>>>
    
    export type UnlikeMutationError = unknown

    /**
 * @summary Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const useUnlike = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlike>>, TError,{diaryId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unlike>>,
        TError,
        {diaryId: number},
        TContext
      > => {

      const mutationOptions = getUnlikeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ïú†Ï†Ä ÌåîÎ°úÏö∞
 */
export const followUser = (
    followeeId: number,
    params: FollowUserParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/follows/${followeeId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getFollowUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{followeeId: number;params: FollowUserParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{followeeId: number;params: FollowUserParams}, TContext> => {

const mutationKey = ['followUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof followUser>>, {followeeId: number;params: FollowUserParams}> = (props) => {
          const {followeeId,params} = props ?? {};

          return  followUser(followeeId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FollowUserMutationResult = NonNullable<Awaited<ReturnType<typeof followUser>>>
    
    export type FollowUserMutationError = unknown

    /**
 * @summary Ïú†Ï†Ä ÌåîÎ°úÏö∞
 */
export const useFollowUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{followeeId: number;params: FollowUserParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof followUser>>,
        TError,
        {followeeId: number;params: FollowUserParams},
        TContext
      > => {

      const mutationOptions = getFollowUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ ÏàòÎùΩ
 */
export const acceptFollow = (
    followId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/follows/${followId}/accept`, method: 'POST', signal
    },
      options);
    }
  


export const getAcceptFollowMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptFollow>>, TError,{followId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof acceptFollow>>, TError,{followId: number}, TContext> => {

const mutationKey = ['acceptFollow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptFollow>>, {followId: number}> = (props) => {
          const {followId} = props ?? {};

          return  acceptFollow(followId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AcceptFollowMutationResult = NonNullable<Awaited<ReturnType<typeof acceptFollow>>>
    
    export type AcceptFollowMutationError = unknown

    /**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ ÏàòÎùΩ
 */
export const useAcceptFollow = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptFollow>>, TError,{followId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof acceptFollow>>,
        TError,
        {followId: number},
        TContext
      > => {

      const mutationOptions = getAcceptFollowMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏûëÏÑ±Ìï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Îì±Î°ù
 */
export const writeDiary = (
    diaryWriteRequestDto: DiaryWriteRequestDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataDiaryResponseDto>(
      {url: `/api/v1/diaries`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: diaryWriteRequestDto, signal
    },
      options);
    }
  


export const getWriteDiaryMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof writeDiary>>, TError,{data: DiaryWriteRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof writeDiary>>, TError,{data: DiaryWriteRequestDto}, TContext> => {

const mutationKey = ['writeDiary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof writeDiary>>, {data: DiaryWriteRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  writeDiary(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WriteDiaryMutationResult = NonNullable<Awaited<ReturnType<typeof writeDiary>>>
    export type WriteDiaryMutationBody = DiaryWriteRequestDto
    export type WriteDiaryMutationError = unknown

    /**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Îì±Î°ù
 */
export const useWriteDiary = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof writeDiary>>, TError,{data: DiaryWriteRequestDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof writeDiary>>,
        TError,
        {data: DiaryWriteRequestDto},
        TContext
      > => {

      const mutationOptions = getWriteDiaryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const signup = (
    signupRequest: SignupRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataObject>(
      {url: `/api/v1/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signupRequest, signal
    },
      options);
    }
  


export const getSignupMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext> => {

const mutationKey = ['signup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, {data: SignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>
    export type SignupMutationBody = SignupRequest
    export type SignupMutationError = unknown

    export const useSignup = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signup>>,
        TError,
        {data: SignupRequest},
        TContext
      > => {

      const mutationOptions = getSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const reissue = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataLoginResponse>(
      {url: `/api/v1/auth/reissue`, method: 'POST', signal
    },
      options);
    }
  


export const getReissueMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reissue>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof reissue>>, TError,void, TContext> => {

const mutationKey = ['reissue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reissue>>, void> = () => {
          

          return  reissue(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReissueMutationResult = NonNullable<Awaited<ReturnType<typeof reissue>>>
    
    export type ReissueMutationError = unknown

    export const useReissue = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reissue>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reissue>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getReissueMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const logout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataObject>(
      {url: `/api/v1/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const login = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataLoginResponse>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = unknown

    export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getUserProfile = (
    userId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataUserProfileResponse>(
      {url: `/api/v1/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserProfileQueryKey = (userId?: number,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserProfileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = unknown>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserProfileQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({ signal }) => getUserProfile(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserProfile>>>
export type GetUserProfileInfiniteQueryError = unknown


export function useGetUserProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = unknown>(
 userId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserProfileInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof getUserProfile>>, TError = unknown>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserProfileQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({ signal }) => getUserProfile(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getUserProfile>>>
export type GetUserProfileQueryError = unknown


export function useGetUserProfile<TData = Awaited<ReturnType<typeof getUserProfile>>, TError = unknown>(
 userId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserProfile<TData = Awaited<ReturnType<typeof getUserProfile>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserProfile<TData = Awaited<ReturnType<typeof getUserProfile>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserProfile<TData = Awaited<ReturnType<typeof getUserProfile>>, TError = unknown>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserProfileQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const searchUsers = (
    params: SearchUsersParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataPageResponseUserProfileResponse>(
      {url: `/api/v1/users/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchUsersQueryKey = (params?: SearchUsersParams,) => {
    return [`/api/v1/users/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchUsersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>, TError = unknown>(params: SearchUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({ signal }) => searchUsers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsers>>>
export type SearchUsersInfiniteQueryError = unknown


export function useSearchUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>, TError = unknown>(
 params: SearchUsersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSearchUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchUsersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchUsersQueryOptions = <TData = Awaited<ReturnType<typeof searchUsers>>, TError = unknown>(params: SearchUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({ signal }) => searchUsers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUsersQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsers>>>
export type SearchUsersQueryError = unknown


export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = unknown>(
 params: SearchUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = unknown>(
 params: SearchUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchUsersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMe = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataMyProfileResponse>(
      {url: `/api/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMeQueryKey = () => {
    return [`/api/v1/users/me`] as const;
    }

    
export const getGetMeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeInfiniteQueryError = unknown


export function useGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Í≥µÍ∞úÎêú ÏùºÍ∏∞ Ïπ¥Îìú Ï°∞Ìöå
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */
export const getPublicTimeline = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TimelineResponse[]>(
      {url: `/api/v1/timeline`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPublicTimelineQueryKey = () => {
    return [`/api/v1/timeline`] as const;
    }

    
export const getGetPublicTimelineInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicTimelineQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicTimeline>>> = ({ signal }) => getPublicTimeline(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPublicTimelineInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicTimeline>>>
export type GetPublicTimelineInfiniteQueryError = unknown


export function useGetPublicTimelineInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublicTimelineInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublicTimelineInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */

export function useGetPublicTimelineInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPublicTimelineInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPublicTimelineQueryOptions = <TData = Awaited<ReturnType<typeof getPublicTimeline>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicTimelineQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicTimeline>>> = ({ signal }) => getPublicTimeline(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPublicTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicTimeline>>>
export type GetPublicTimelineQueryError = unknown


export function useGetPublicTimeline<TData = Awaited<ReturnType<typeof getPublicTimeline>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublicTimeline<TData = Awaited<ReturnType<typeof getPublicTimeline>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublicTimeline<TData = Awaited<ReturnType<typeof getPublicTimeline>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */

export function useGetPublicTimeline<TData = Awaited<ReturnType<typeof getPublicTimeline>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPublicTimelineQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Îì±Î°ùÎêú Î™®Îì† ÌÉúÍ∑∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */
export const getAllTags = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataListTagResponse>(
      {url: `/api/v1/tags`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllTagsQueryKey = () => {
    return [`/api/v1/tags`] as const;
    }

    
export const getGetAllTagsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTags>>> = ({ signal }) => getAllTags(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTags>>>
export type GetAllTagsInfiniteQueryError = unknown


export function useGetAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */

export function useGetAllTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTagsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllTagsQueryOptions = <TData = Awaited<ReturnType<typeof getAllTags>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTags>>> = ({ signal }) => getAllTags(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTags>>>
export type GetAllTagsQueryError = unknown


export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */

export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTagsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÏΩòÌÖêÏ∏† ÌÉÄÏûÖÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */
export const getTypeGraph = (
    params: GetTypeGraphParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TypeGraphResponse>(
      {url: `/api/v1/statistics/type-graph`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTypeGraphQueryKey = (params?: GetTypeGraphParams,) => {
    return [`/api/v1/statistics/type-graph`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTypeGraphInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>, TError = unknown>(params: GetTypeGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTypeGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeGraph>>> = ({ signal }) => getTypeGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTypeGraphInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTypeGraph>>>
export type GetTypeGraphInfiniteQueryError = unknown


export function useGetTypeGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>, TError = unknown>(
 params: GetTypeGraphParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */

export function useGetTypeGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTypeGraphInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTypeGraphQueryOptions = <TData = Awaited<ReturnType<typeof getTypeGraph>>, TError = unknown>(params: GetTypeGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTypeGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeGraph>>> = ({ signal }) => getTypeGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTypeGraphQueryResult = NonNullable<Awaited<ReturnType<typeof getTypeGraph>>>
export type GetTypeGraphQueryError = unknown


export function useGetTypeGraph<TData = Awaited<ReturnType<typeof getTypeGraph>>, TError = unknown>(
 params: GetTypeGraphParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeGraph<TData = Awaited<ReturnType<typeof getTypeGraph>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeGraph<TData = Awaited<ReturnType<typeof getTypeGraph>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */

export function useGetTypeGraph<TData = Awaited<ReturnType<typeof getTypeGraph>>, TError = unknown>(
 params: GetTypeGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTypeGraphQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÌäπÏ†ï ÌöåÏõêÏùò ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨Î•º Ï°∞ÌöåÌï©ÎãàÎã§
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */
export const getTypeDistribution = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TypeCountDto[]>(
      {url: `/api/v1/statistics/type-distribution`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTypeDistributionQueryKey = () => {
    return [`/api/v1/statistics/type-distribution`] as const;
    }

    
export const getGetTypeDistributionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTypeDistributionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeDistribution>>> = ({ signal }) => getTypeDistribution(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTypeDistributionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTypeDistribution>>>
export type GetTypeDistributionInfiniteQueryError = unknown


export function useGetTypeDistributionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeDistributionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeDistributionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */

export function useGetTypeDistributionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTypeDistributionInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTypeDistributionQueryOptions = <TData = Awaited<ReturnType<typeof getTypeDistribution>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTypeDistributionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeDistribution>>> = ({ signal }) => getTypeDistribution(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTypeDistributionQueryResult = NonNullable<Awaited<ReturnType<typeof getTypeDistribution>>>
export type GetTypeDistributionQueryError = unknown


export function useGetTypeDistribution<TData = Awaited<ReturnType<typeof getTypeDistribution>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeDistribution<TData = Awaited<ReturnType<typeof getTypeDistribution>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTypeDistribution<TData = Awaited<ReturnType<typeof getTypeDistribution>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */

export function useGetTypeDistribution<TData = Awaited<ReturnType<typeof getTypeDistribution>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTypeDistribution>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTypeDistributionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * OTTÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary OTT Í∑∏ÎûòÌîÑ
 */
export const getOttGraph = (
    params: GetOttGraphParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OttGraphResponse>(
      {url: `/api/v1/statistics/ott-graph`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetOttGraphQueryKey = (params?: GetOttGraphParams,) => {
    return [`/api/v1/statistics/ott-graph`, ...(params ? [params]: [])] as const;
    }

    
export const getGetOttGraphInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>, TError = unknown>(params: GetOttGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOttGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOttGraph>>> = ({ signal }) => getOttGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOttGraphInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOttGraph>>>
export type GetOttGraphInfiniteQueryError = unknown


export function useGetOttGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>, TError = unknown>(
 params: GetOttGraphParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOttGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOttGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OTT Í∑∏ÎûòÌîÑ
 */

export function useGetOttGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOttGraphInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOttGraphQueryOptions = <TData = Awaited<ReturnType<typeof getOttGraph>>, TError = unknown>(params: GetOttGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOttGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOttGraph>>> = ({ signal }) => getOttGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOttGraphQueryResult = NonNullable<Awaited<ReturnType<typeof getOttGraph>>>
export type GetOttGraphQueryError = unknown


export function useGetOttGraph<TData = Awaited<ReturnType<typeof getOttGraph>>, TError = unknown>(
 params: GetOttGraphParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOttGraph<TData = Awaited<ReturnType<typeof getOttGraph>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOttGraph<TData = Awaited<ReturnType<typeof getOttGraph>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OTT Í∑∏ÎûòÌîÑ
 */

export function useGetOttGraph<TData = Awaited<ReturnType<typeof getOttGraph>>, TError = unknown>(
 params: GetOttGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOttGraphQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÌäπÏ†ï ÌöåÏõêÏùò ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */
export const getLast6MonthsDiaryCounts = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MonthlyDiaryCount[]>(
      {url: `/api/v1/statistics/monthly-diary-graph`, method: 'GET', signal
    },
      options);
    }
  

export const getGetLast6MonthsDiaryCountsQueryKey = () => {
    return [`/api/v1/statistics/monthly-diary-graph`] as const;
    }

    
export const getGetLast6MonthsDiaryCountsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLast6MonthsDiaryCountsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>> = ({ signal }) => getLast6MonthsDiaryCounts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLast6MonthsDiaryCountsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>
export type GetLast6MonthsDiaryCountsInfiniteQueryError = unknown


export function useGetLast6MonthsDiaryCountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLast6MonthsDiaryCountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLast6MonthsDiaryCountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */

export function useGetLast6MonthsDiaryCountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLast6MonthsDiaryCountsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetLast6MonthsDiaryCountsQueryOptions = <TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLast6MonthsDiaryCountsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>> = ({ signal }) => getLast6MonthsDiaryCounts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLast6MonthsDiaryCountsQueryResult = NonNullable<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>
export type GetLast6MonthsDiaryCountsQueryError = unknown


export function useGetLast6MonthsDiaryCounts<TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLast6MonthsDiaryCounts<TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLast6MonthsDiaryCounts<TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */

export function useGetLast6MonthsDiaryCounts<TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLast6MonthsDiaryCountsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ïû•Î•¥Ïóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */
export const getGenreGraph = (
    params: GetGenreGraphParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GenreGraphResponse>(
      {url: `/api/v1/statistics/genre-graph`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGenreGraphQueryKey = (params?: GetGenreGraphParams,) => {
    return [`/api/v1/statistics/genre-graph`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGenreGraphInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>, TError = unknown>(params: GetGenreGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGenreGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreGraph>>> = ({ signal }) => getGenreGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGenreGraphInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGenreGraph>>>
export type GetGenreGraphInfiniteQueryError = unknown


export function useGetGenreGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>, TError = unknown>(
 params: GetGenreGraphParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenreGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenreGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */

export function useGetGenreGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGenreGraphInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGenreGraphQueryOptions = <TData = Awaited<ReturnType<typeof getGenreGraph>>, TError = unknown>(params: GetGenreGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGenreGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreGraph>>> = ({ signal }) => getGenreGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGenreGraphQueryResult = NonNullable<Awaited<ReturnType<typeof getGenreGraph>>>
export type GetGenreGraphQueryError = unknown


export function useGetGenreGraph<TData = Awaited<ReturnType<typeof getGenreGraph>>, TError = unknown>(
 params: GetGenreGraphParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenreGraph<TData = Awaited<ReturnType<typeof getGenreGraph>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenreGraph<TData = Awaited<ReturnType<typeof getGenreGraph>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */

export function useGetGenreGraph<TData = Awaited<ReturnType<typeof getGenreGraph>>, TError = unknown>(
 params: GetGenreGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGenreGraphQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Í∞êÏ†ïÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */
export const getEmotionGraph = (
    params: GetEmotionGraphParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EmotionGraphResponse>(
      {url: `/api/v1/statistics/emotion-graph`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetEmotionGraphQueryKey = (params?: GetEmotionGraphParams,) => {
    return [`/api/v1/statistics/emotion-graph`, ...(params ? [params]: [])] as const;
    }

    
export const getGetEmotionGraphInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>, TError = unknown>(params: GetEmotionGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmotionGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmotionGraph>>> = ({ signal }) => getEmotionGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEmotionGraphInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getEmotionGraph>>>
export type GetEmotionGraphInfiniteQueryError = unknown


export function useGetEmotionGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>, TError = unknown>(
 params: GetEmotionGraphParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmotionGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmotionGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */

export function useGetEmotionGraphInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEmotionGraphInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmotionGraphQueryOptions = <TData = Awaited<ReturnType<typeof getEmotionGraph>>, TError = unknown>(params: GetEmotionGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmotionGraphQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmotionGraph>>> = ({ signal }) => getEmotionGraph(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEmotionGraphQueryResult = NonNullable<Awaited<ReturnType<typeof getEmotionGraph>>>
export type GetEmotionGraphQueryError = unknown


export function useGetEmotionGraph<TData = Awaited<ReturnType<typeof getEmotionGraph>>, TError = unknown>(
 params: GetEmotionGraphParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmotionGraph<TData = Awaited<ReturnType<typeof getEmotionGraph>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmotionGraph<TData = Awaited<ReturnType<typeof getEmotionGraph>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */

export function useGetEmotionGraph<TData = Awaited<ReturnType<typeof getEmotionGraph>>, TError = unknown>(
 params: GetEmotionGraphParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmotionGraph>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEmotionGraphQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ï¥ù Í∞êÏÉÅ Ïàò, ÌèâÍ∑† Î≥ÑÏ†ï, ÏÑ†Ìò∏ Ïû•Î•¥, Ï£ºÏöî Í∞êÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */
export const getStatisticsCard = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StatisticsCardDto>(
      {url: `/api/v1/statistics/card`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStatisticsCardQueryKey = () => {
    return [`/api/v1/statistics/card`] as const;
    }

    
export const getGetStatisticsCardInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsCardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsCard>>> = ({ signal }) => getStatisticsCard(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStatisticsCardInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsCard>>>
export type GetStatisticsCardInfiniteQueryError = unknown


export function useGetStatisticsCardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatisticsCardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatisticsCardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */

export function useGetStatisticsCardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStatisticsCardInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStatisticsCardQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsCard>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsCardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsCard>>> = ({ signal }) => getStatisticsCard(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStatisticsCardQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsCard>>>
export type GetStatisticsCardQueryError = unknown


export function useGetStatisticsCard<TData = Awaited<ReturnType<typeof getStatisticsCard>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatisticsCard<TData = Awaited<ReturnType<typeof getStatisticsCard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatisticsCard<TData = Awaited<ReturnType<typeof getStatisticsCard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */

export function useGetStatisticsCard<TData = Awaited<ReturnType<typeof getStatisticsCard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsCard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStatisticsCardQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */
export const getLikeCount = (
    params: GetLikeCountParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LikeCountResponse>(
      {url: `/api/v1/likes/count`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetLikeCountQueryKey = (params?: GetLikeCountParams,) => {
    return [`/api/v1/likes/count`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLikeCountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>, TError = unknown>(params: GetLikeCountParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLikeCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLikeCount>>> = ({ signal }) => getLikeCount(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLikeCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getLikeCount>>>
export type GetLikeCountInfiniteQueryError = unknown


export function useGetLikeCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>, TError = unknown>(
 params: GetLikeCountParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLikeCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLikeCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetLikeCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLikeCountInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetLikeCountQueryOptions = <TData = Awaited<ReturnType<typeof getLikeCount>>, TError = unknown>(params: GetLikeCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLikeCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLikeCount>>> = ({ signal }) => getLikeCount(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLikeCountQueryResult = NonNullable<Awaited<ReturnType<typeof getLikeCount>>>
export type GetLikeCountQueryError = unknown


export function useGetLikeCount<TData = Awaited<ReturnType<typeof getLikeCount>>, TError = unknown>(
 params: GetLikeCountParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLikeCount<TData = Awaited<ReturnType<typeof getLikeCount>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLikeCount<TData = Awaited<ReturnType<typeof getLikeCount>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetLikeCount<TData = Awaited<ReturnType<typeof getLikeCount>>, TError = unknown>(
 params: GetLikeCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLikeCountQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÏïÑÏßÅ ÏàòÎùΩÎêòÏßÄ ÏïäÏùÄ PENDING ÏÉÅÌÉúÏùò ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */
export const getSentRequests = (
    params: GetSentRequestsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FollowUserResponse[]>(
      {url: `/api/v1/follows/sent-requests`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSentRequestsQueryKey = (params?: GetSentRequestsParams,) => {
    return [`/api/v1/follows/sent-requests`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSentRequestsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>, TError = unknown>(params: GetSentRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSentRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSentRequests>>> = ({ signal }) => getSentRequests(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSentRequestsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSentRequests>>>
export type GetSentRequestsInfiniteQueryError = unknown


export function useGetSentRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>, TError = unknown>(
 params: GetSentRequestsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSentRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSentRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetSentRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSentRequestsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSentRequestsQueryOptions = <TData = Awaited<ReturnType<typeof getSentRequests>>, TError = unknown>(params: GetSentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSentRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSentRequests>>> = ({ signal }) => getSentRequests(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSentRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof getSentRequests>>>
export type GetSentRequestsQueryError = unknown


export function useGetSentRequests<TData = Awaited<ReturnType<typeof getSentRequests>>, TError = unknown>(
 params: GetSentRequestsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSentRequests<TData = Awaited<ReturnType<typeof getSentRequests>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSentRequests<TData = Awaited<ReturnType<typeof getSentRequests>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetSentRequests<TData = Awaited<ReturnType<typeof getSentRequests>>, TError = unknown>(
 params: GetSentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSentRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * PENDING ÏÉÅÌÉúÏùò ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */
export const getPendingRequests = (
    params: GetPendingRequestsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FollowUserResponse[]>(
      {url: `/api/v1/follows/requests`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetPendingRequestsQueryKey = (params?: GetPendingRequestsParams,) => {
    return [`/api/v1/follows/requests`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPendingRequestsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>, TError = unknown>(params: GetPendingRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPendingRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingRequests>>> = ({ signal }) => getPendingRequests(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPendingRequestsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingRequests>>>
export type GetPendingRequestsInfiniteQueryError = unknown


export function useGetPendingRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>, TError = unknown>(
 params: GetPendingRequestsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingRequestsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPendingRequestsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPendingRequestsQueryOptions = <TData = Awaited<ReturnType<typeof getPendingRequests>>, TError = unknown>(params: GetPendingRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPendingRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingRequests>>> = ({ signal }) => getPendingRequests(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPendingRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingRequests>>>
export type GetPendingRequestsQueryError = unknown


export function useGetPendingRequests<TData = Awaited<ReturnType<typeof getPendingRequests>>, TError = unknown>(
 params: GetPendingRequestsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingRequests<TData = Awaited<ReturnType<typeof getPendingRequests>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingRequests<TData = Awaited<ReturnType<typeof getPendingRequests>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingRequests<TData = Awaited<ReturnType<typeof getPendingRequests>>, TError = unknown>(
 params: GetPendingRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPendingRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ACCEPTED ÏÉÅÌÉúÏùò Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getFollowings = (
    params: GetFollowingsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FollowUserResponse[]>(
      {url: `/api/v1/follows/followings`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetFollowingsQueryKey = (params?: GetFollowingsParams,) => {
    return [`/api/v1/follows/followings`, ...(params ? [params]: [])] as const;
    }

    
export const getGetFollowingsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>, TError = unknown>(params: GetFollowingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFollowingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowings>>> = ({ signal }) => getFollowings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFollowingsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFollowings>>>
export type GetFollowingsInfiniteQueryError = unknown


export function useGetFollowingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>, TError = unknown>(
 params: GetFollowingsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFollowingsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFollowingsQueryOptions = <TData = Awaited<ReturnType<typeof getFollowings>>, TError = unknown>(params: GetFollowingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFollowingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowings>>> = ({ signal }) => getFollowings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFollowingsQueryResult = NonNullable<Awaited<ReturnType<typeof getFollowings>>>
export type GetFollowingsQueryError = unknown


export function useGetFollowings<TData = Awaited<ReturnType<typeof getFollowings>>, TError = unknown>(
 params: GetFollowingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowings<TData = Awaited<ReturnType<typeof getFollowings>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowings<TData = Awaited<ReturnType<typeof getFollowings>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowings<TData = Awaited<ReturnType<typeof getFollowings>>, TError = unknown>(
 params: GetFollowingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFollowingsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ACCEPTED ÏÉÅÌÉúÏùò Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getFollowers = (
    params: GetFollowersParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FollowUserResponse[]>(
      {url: `/api/v1/follows/followers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetFollowersQueryKey = (params?: GetFollowersParams,) => {
    return [`/api/v1/follows/followers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetFollowersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>, TError = unknown>(params: GetFollowersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFollowersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowers>>> = ({ signal }) => getFollowers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFollowersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFollowers>>>
export type GetFollowersInfiniteQueryError = unknown


export function useGetFollowersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>, TError = unknown>(
 params: GetFollowersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFollowersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFollowersQueryOptions = <TData = Awaited<ReturnType<typeof getFollowers>>, TError = unknown>(params: GetFollowersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFollowersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowers>>> = ({ signal }) => getFollowers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFollowersQueryResult = NonNullable<Awaited<ReturnType<typeof getFollowers>>>
export type GetFollowersQueryError = unknown


export function useGetFollowers<TData = Awaited<ReturnType<typeof getFollowers>>, TError = unknown>(
 params: GetFollowersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowers<TData = Awaited<ReturnType<typeof getFollowers>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFollowers<TData = Awaited<ReturnType<typeof getFollowers>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowers<TData = Awaited<ReturnType<typeof getFollowers>>, TError = unknown>(
 params: GetFollowersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFollowersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */
export const getContent = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataContentResponseDto>(
      {url: `/api/v1/contents/${diaryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetContentQueryKey = (diaryId?: number,) => {
    return [`/api/v1/contents/${diaryId}`] as const;
    }

    
export const getGetContentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetContentQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getContent>>> = ({ signal }) => getContent(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetContentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getContent>>>
export type GetContentInfiniteQueryError = unknown


export function useGetContentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */

export function useGetContentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetContentInfiniteQueryOptions(diaryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetContentQueryOptions = <TData = Awaited<ReturnType<typeof getContent>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetContentQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getContent>>> = ({ signal }) => getContent(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetContentQueryResult = NonNullable<Awaited<ReturnType<typeof getContent>>>
export type GetContentQueryError = unknown


export function useGetContent<TData = Awaited<ReturnType<typeof getContent>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContent<TData = Awaited<ReturnType<typeof getContent>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContent<TData = Awaited<ReturnType<typeof getContent>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */

export function useGetContent<TData = Awaited<ReturnType<typeof getContent>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetContentQueryOptions(diaryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ïª®ÌÖêÏ∏†Î•º Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */
export const searchContents = (
    params: SearchContentsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataListContentSearchResultDto>(
      {url: `/api/v1/contents/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchContentsQueryKey = (params?: SearchContentsParams,) => {
    return [`/api/v1/contents/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchContentsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>, TError = unknown>(params: SearchContentsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchContentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchContents>>> = ({ signal }) => searchContents(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchContentsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchContents>>>
export type SearchContentsInfiniteQueryError = unknown


export function useSearchContentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>, TError = unknown>(
 params: SearchContentsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchContentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchContentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */

export function useSearchContentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchContentsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchContentsQueryOptions = <TData = Awaited<ReturnType<typeof searchContents>>, TError = unknown>(params: SearchContentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchContentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchContents>>> = ({ signal }) => searchContents(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchContentsQueryResult = NonNullable<Awaited<ReturnType<typeof searchContents>>>
export type SearchContentsQueryError = unknown


export function useSearchContents<TData = Awaited<ReturnType<typeof searchContents>>, TError = unknown>(
 params: SearchContentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchContents<TData = Awaited<ReturnType<typeof searchContents>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchContents<TData = Awaited<ReturnType<typeof searchContents>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */

export function useSearchContents<TData = Awaited<ReturnType<typeof searchContents>>, TError = unknown>(
 params: SearchContentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchContentsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */
export const getComments = (
    diaryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RsDataListCommentResponseDto>(
      {url: `/api/v1/comments/${diaryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCommentsQueryKey = (diaryId?: number,) => {
    return [`/api/v1/comments/${diaryId}`] as const;
    }

    
export const getGetCommentsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({ signal }) => getComments(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCommentsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getComments>>>
export type GetCommentsInfiniteQueryError = unknown


export function useGetCommentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useGetCommentsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCommentsInfiniteQueryOptions(diaryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsQueryKey(diaryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({ signal }) => getComments(diaryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(diaryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getComments>>>
export type GetCommentsQueryError = unknown


export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 diaryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 diaryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCommentsQueryOptions(diaryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ÌåîÎ°úÏö∞ Í¥ÄÍ≥Ñ ÎÅäÍ∏∞ (Ïñ∏ÌåîÎ°úÏö∞)
 */
export const unfollowUser = (
    otherUserId: number,
    params: UnfollowUserParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/follows/${otherUserId}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getUnfollowUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowUser>>, TError,{otherUserId: number;params: UnfollowUserParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unfollowUser>>, TError,{otherUserId: number;params: UnfollowUserParams}, TContext> => {

const mutationKey = ['unfollowUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unfollowUser>>, {otherUserId: number;params: UnfollowUserParams}> = (props) => {
          const {otherUserId,params} = props ?? {};

          return  unfollowUser(otherUserId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnfollowUserMutationResult = NonNullable<Awaited<ReturnType<typeof unfollowUser>>>
    
    export type UnfollowUserMutationError = unknown

    /**
 * @summary ÌåîÎ°úÏö∞ Í¥ÄÍ≥Ñ ÎÅäÍ∏∞ (Ïñ∏ÌåîÎ°úÏö∞)
 */
export const useUnfollowUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowUser>>, TError,{otherUserId: number;params: UnfollowUserParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unfollowUser>>,
        TError,
        {otherUserId: number;params: UnfollowUserParams},
        TContext
      > => {

      const mutationOptions = getUnfollowUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Í±∞Ï†à
 */
export const rejectFollow = (
    followId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/follows/${followId}/reject`, method: 'DELETE'
    },
      options);
    }
  


export const getRejectFollowMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectFollow>>, TError,{followId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rejectFollow>>, TError,{followId: number}, TContext> => {

const mutationKey = ['rejectFollow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectFollow>>, {followId: number}> = (props) => {
          const {followId} = props ?? {};

          return  rejectFollow(followId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RejectFollowMutationResult = NonNullable<Awaited<ReturnType<typeof rejectFollow>>>
    
    export type RejectFollowMutationError = unknown

    /**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Í±∞Ï†à
 */
export const useRejectFollow = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectFollow>>, TError,{followId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rejectFollow>>,
        TError,
        {followId: number},
        TContext
      > => {

      const mutationOptions = getRejectFollowMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const deleteComment = (
    commentId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RsDataVoid>(
      {url: `/api/v1/comments/${commentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{commentId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{commentId: number}, TContext> => {

const mutationKey = ['deleteComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteComment>>, {commentId: number}> = (props) => {
          const {commentId} = props ?? {};

          return  deleteComment(commentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>
    
    export type DeleteCommentMutationError = unknown

    /**
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const useDeleteComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{commentId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteComment>>,
        TError,
        {commentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteCommentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
